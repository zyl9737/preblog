<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[攻防世界web新手区题解]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目：view_source这道题没啥好说的，f12即可flag：cyberpeace{e07dcafaeeb31df23b4d661dd4da56f9} 题目：get_post这道题我使用的方法是：旧版本火狐+旧版本的hackbar hackbar勾选Post，load URL内容为：http://111.198.29.45:33495/?a=1，post data内容为：b=2，然后点击Execute即可看到flag了 flag：cyberpeace{c4e43c9c9d0f729358dd9417219a9da0} 题目:robots这个题考到了Robots协议，也就是爬虫排除标准，于是肯定有个robots.txt文件，直接构造url访问这个文件，看到了禁止爬取：f1ag_1s_h3re.php这个页面，我们直接访问这个页面于是便得到了flag了 flag：cyberpeace{1b59446bc8e566382e01b0c209b899bd} 题目：backup这道题考察的是备份文件漏洞，产生该类漏洞的方式一般又三个： 编辑器自动备份 版本控制系统备份 开发者主动备份 于是我们知道了备份文件：index.php.bak 下载后便得到flag了 flag：cyberpeace{4376485b1a095581d7fb57b8ab3bb924} 题目：cookie Cookie是当主机访问Web服务器时，由 Web 服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。 浏览器按下F12键打开开发者工具，刷新后，在存储一栏，可看到名为look-here的cookie的值为cookie.php 访问http://111.198.29.45:47911/cookie.php，提示查看http响应包，在网络一栏，可看到访问cookie.php的数据包 点击查看数据包，在消息头内可发现flag flag：cyberpeace{e865c062128d651191621df4662b3573} 题目：disabled_button这个题对于前端工作者来说绝对的简单的不能再简单了，直接删除掉disabled属性，就可以点击了 flag：cyberpeace{2e978e2dde5d8acdd7ff76f1c426bb29} 题目:simple_js这个题真正的密码部分因该是：\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30 先要把这段16进制转换成10进制得到：55,56,54,79,115,69,114,116,107,49,50 然后直接一段python脚本解得flag s=[55,56,54,79,115,69,114,116,107,49,50]for i in s:print(chr(i),end=’’)flag：Cyberpeace{786OsErtk12} 题目：xff_referer直接刷新一下burp截包，然后添加如下两行内容： X-Forwarded-For:123.123.123.123 Referer:https://www.google.com 然后就看到flag了 flag：cyberpeace{63657c0c7f88a39a475f0de726ef109a} 题目：weak_auth打开网页看到标题提示weak auth弱验证，这就没啥好说的了，没看到验证码，burp直接来爆破吧！ 随便输入下用户名和密码,提示要用admin用户登入,然后跳转到了check.php,查看下源代码提示要用字典。 用burpsuite截下登录的数据包,把数据包发送到intruder爆破 设置爆破点为password 加载字典 开始攻击，查看响应包列表，发现密码为123456时，响应包的长度和别的不一样. 于是便得到了flag flag：cyberpeace{04415bd2dac05f0e2cd712bb43c447b2} 题目：webshell这个没啥好说的，菜刀连接上后发现目录下有个flag.txt，打开就看到了flag了 flag：cyberpeace{74fea3cfddba6bfdc6bfba5b38300b08} 题目：command_execution打开网页在标题看到command execution 命令执行，那就没啥好说的了，看看目录下有些啥吧! ping -c 3 3 127.0.0.1 | ls /binbootdevetchomeliblib64mediamntoptprocrootrunrun.shsbinsrvsystmpusrvar习惯性的看看home里有什么 ping -c 3 127.0.0.1 | ls /homeflag.txtping -c 3 3 127.0.0.1 | cat /home/flag.txtcyberpeace{39190fc825ce46b116b6829f0c13d625}于是便得到了flag！ flag：cyberpeace{39190fc825ce46b116b6829f0c13d625} 题目：simple_php这道题在阅读了PHP代码后，发现，要a==0，但a的值又不能为0，因此让a=0+任意非数字字符，而 b=数字就退出， 于是构造：?a=0a&amp;b=12345A便得到完整的flag flag：Cyberpeace{647E37C7627CC3E4019EC69324F66C7C}]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机漏洞安全相关的概念]]></title>
    <url>%2F2019%2F08%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%BC%8F%E6%B4%9E%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[最近在学校的网安协会招新群里做了几个CTF题，发现还是挺有意思的（其实我大一上就加入了，不过是潜水怪，纯混子）算是重拾对网安的兴趣吧。 POCPOC，Proof ofConcept，中文意思是“观点证明”。这个短语会在漏洞报告中使用，漏洞报告中的POC则是一段说明或者一个攻击的样例，使得读者能够确认这个漏洞是真实存在的。 EXPExploit，中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。 VULVUL，Vulnerability的缩写，泛指漏洞。 CVECVE 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露，例如CVE-2015-0057、CVE-1999-0001等等。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。如果在一个漏洞报告中指明的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。 可以在https://cve.mitre.org/ 网站根据漏洞的CVE编号搜索该漏洞的介绍。 也可以在中文社区http://www.scap.org.cn/ 上搜索关于漏洞的介绍 0DAY漏洞和0DAY攻击在计算机领域中，零日漏洞或零时差漏洞（英语：Zero-dayexploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（英语：Zero-dayattack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。零日漏洞及其利用代码不仅对犯罪黑客而言，具有极高的利用价值，一些国家间谍和网军部队，例如美国国家安全局和美国网战司令部也非常重视这些信息。据路透社报告称美国政府是零日漏洞黑市的最大买家。]]></content>
      <tags>
        <tag>漏洞安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[V2Ray服务器搭建科学上网]]></title>
    <url>%2F2019%2F07%2F04%2FV2ray%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[本文从零开始，手把手教你搭建自己的V2ray和SS服务器实现全球互联。史上最详细的小白搭建V2ray和ss教程。内容包括VPS购买，连接VPS，一键搭建V2ray和SS，开启bbr加速，客户端配置。 购买境外VPS服务器首先进入Vultr官网注册：https://www.vultr.com （通过此链接注册充值10美元送50美元）注意：密码首字母需要大写，且长度需要超过10个字符！！！ 再次确认一遍注册邮箱和密码 登录并进入充值界面进行充值 支持信用卡，支付宝，微信支付。创建服务器点击右上方 “+” 号来创建服务器。选择服务器机房 推荐使用东京和新加坡服务器，物理距离近，延迟要低不少。 选择东京服务器可能需要点耐心，因为使用的人比较多，好多IP被墙，没有耐心的可以选择新加坡服务器。 查询服务器是否被墙下面会有讲到。选择服务器操作系统及配置 选择服务器系统，仅推荐使用Debian9 ，使用其他操作系统可能会有一些列问题。 选择完毕点击创建。 服务器规格选择3.5美元的足矣点击我们刚刚创建的服务器 进入查看服务器配置参数复制服务器IP地址服务器端口扫描 使用端口扫描工具扫描我们创建的服务器IP，查看22端口是否开放，如果是关闭的话按照上面教程重新创建服务器，直到“22”端口为开放状态。 然后再删除之前被墙的服务器，Vultr服务器是按小时收费的，所以我们刚刚创建的服务器删除的话是不收费的。 端口扫描工具我使用的是 http://coolaf.com/tool/port 你也可以上百度搜索端口扫描工具即可。 使用Xshell终端连接服务器安装Xshell Xshell 官网下载 安装完成后打开软件，新建会话。填入服务器IP地址 输入一个名称，方便自己以后管理。 填入服务器IP地址。回到Vultr，复制服务器密码填入服务器用户名及密码 点击用户身份验证 填入服务器用户名root（Vultr用户名默认都是root） 粘贴刚才复制的密码 点击“连接”SSH安全警告 首次连接服务器会出现SSH安全警告，点击“接受并保持”即可 搭建V2ray使用一键安装脚本安装V2ray 推荐使用一键安装脚本，一行代码解决所有问题。 复制下面的代码，然后在Xshell 黑色处点击右键粘贴，然后回车安装。（这里不能使用Ctrl+V粘贴）bash &lt;(curl -s -L https://git.io/v2ray.sh) 也可以通过谷歌云安装官方脚本(据说上面的脚本有后门，对安全性要求高的可以选这个)v2ray官网v2ray配置文件生成器输入 “1” 进行安装选择传输协议 没有特殊需要就直接回车，使用默认的TCP协议。选择端口号 输入端口号，这个自己随意，但是未了避免和以后折腾其他的东西冲突，推荐使用1000以上的端口号但是不能超过65535 建议直接输入“10086” （没有特殊意义，单纯为了好记，PS：中国移动记得给我广告费）广告拦截是否开启广告拦截，看自己需要吧，推荐不要开启，开启广告拦截会消耗服务器资源，国外环境要比国内好得多。开启SS 最好是开启，后面使用游戏加速器会用得上。选择SS端口号 SS端口号，还是随意。但是千万不要和上面V2ray的端口号冲突。输入SS连接密码这个没有要求，只要你自己能记得住就行，越简单越好。选择SS加密协议 不多说，推荐使用默认的。搭建完成 接下来就是回车，回车。 然后喝杯咖啡，等待几分钟，出现下面这个界面就表示服务器搭建完成了 开启BBR 如果使用的是Debian9 系统，BBR是自动开启的。 Ubuntu 18.04/18.10开启BBR加速: Step 1：修改系统变量 12echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf Step 2:保存生效sysctl -p Step 3：检查BBR是否开启sysctl net.ipv4.tcp_available_congestion_control如果 返回net.ipv4.tcp_available_congestion_control = bbr cubic reno则 开启 成功！ Step 4：检查BBR是否启动成功lsmod | grep bbr如果 返回tcp_bbr 20480 14则 启动 成功 CentOS 7 开启BBR加速 客户端使用 V2ray和SS客户端使用教程 物尽其用这么高配置的服务器只用来搭建梯子服务器？未免也太浪费了吧，接下来教你在梯子服务器的基础上再搭建一个 个人网盘服务器。 使用NextCloud搭建个人网盘服务器]]></content>
      <tags>
        <tag>v2ray</tag>
        <tag>科学上网</tag>
        <tag>vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特币与区块链入门]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[虚拟货币终将迎来春天 区块链入门比特币入门加密货币的本质知乎大佬靠比特币实现财务自由论坛 阮老师写得很通俗易懂了，关于比特币争议也很大，有看好的也有嗤之以鼻的，看了知乎上前段时间的孙宇晨买下巴菲特午餐的讨论，只想说，币圈真乱。我对很多事情都有极大的兴趣，想探索任何未知的东西，我认为好奇心在人的一生中是至关重要的。我不相信人，认为人的行为是不可控的，所以我非常宅。我相信机器，因为机器的结果都能在我的掌控中。]]></content>
      <tags>
        <tag>哎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next如何在文章摘要展示图片]]></title>
    <url>%2F2019%2F06%2F28%2FHexo-Next%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[一般有两种方法 在文章的属性列表中添加photos属性编写的文章属性中photos默认为文章的配图，这是我目前最喜欢的配图方式，但是有一个缺点，它不能自定义裁剪和缩略比，展示的是原图，这相当于如果你的每张配图大小比例不一致将会很影响美观性，目前没有很好的解决方案，所以只好自己裁剪好再引入。 如这篇文章：12345678---title: Hexo Next如何在文章摘要展示图片date: 2019-06-28 17:43:44tags: Hexocategories: Hexophotos: - "xxx"--- 在你的正文中使用&lt;!-- more --&gt;进行截断由于markdown是支持原生html的，所以我们可以在正文引用img来为我们的文章设置摘要配图,在&lt;!-- more --&gt;之前的内容都会展示到摘要中(同时与你主题文件中配置的摘要字数有关).如：123456789---title: Hexo Next如何在文章摘要展示图片date: 2019-06-28 17:43:44tags: Hexocategories: Hexo---&lt;img src="XXX" width=50% /&gt;哇，漂亮的小姐姐(❤ ω ❤)&lt;!--more--&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记及一些杂谈]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[YOLO]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建个人博客]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%9D%A5%E8%87%AAwd%E5%AD%A6%E9%95%BF%E7%9A%84%E5%8F%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[友链加上各种谷歌加百度就能建站了（很容易的，我也就熬了几个夜]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1054 求平均值]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1054 求平均值 （20 分) 本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。输入格式：输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。输出格式：对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。输入样例 1：75 -3.2 aaa 9999 2.3.4 7.123 2.35输出样例 1：ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38输入样例 2：2aaa -9999输出样例 2：ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 分析：使用sscanf和sprintf函数～sscanf() – 从一个字符串中读进与指定格式相符的数据sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中 题解：12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int n,cnt=0; char a[50],b[50]; cin&gt;&gt;n; double temp,sum=0.0; for(int i=0;i&lt;n;i++) &#123; scanf("%s",a); sscanf(a,"%lf",&amp;temp);//从7.123中读入7.123道temp中 sprintf(b,"%.2f",temp);//把temp变为7.12写入b中 int flag=0; for(int j=0;j&lt;strlen(a);j++) if(a[j]!=b[j])flag=1; if(flag||temp&lt;-1000||temp&gt;1000) &#123; printf("ERROR: %s is not a legal number\n",a); continue; &#125; else &#123; sum+=temp; cnt++; &#125; &#125; if(cnt==1) printf("The average of 1 number is %.2f",sum); else if(cnt&gt;1) printf("The average of %d numbers is %.2f",cnt,sum/cnt); else printf("The average of 0 numbers is Undefined"); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1057 数壹零]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1057-%E6%95%B0%E5%A3%B9%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[1057 数零壹 （20 分) 给定一串长度不超过 10^5的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 PAT (Basic)，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。输入格式：输入在一行中给出长度不超过 10^5,以回车结束的字符串。输出格式：在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。输入样例：PAT (Basic)输出样例：3 4 分析：用getline接收一行字符串，对于字符串的每一位，如果是字母(isalpha)，则将字母转化为大写(toupper)，并累加(s[i] – ‘A’ + 1)算出n，然后将n转化为二进制，对每一位处理，如果是0则cnt0++，如果是1则cnt1++，最后输出cnt0和cnt1的值～～题解：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;using namespace std;int main()&#123; string s; getline(cin,s); int n=0; for(int i=0;i&lt;s.length();i++) &#123; if(isalpha(s[i])) &#123; s[i]=toupper(s[i]); n+=(s[i]-'A'+1); &#125; &#125; int cnt0=0,cnt1=0; while(n!=0) &#123; if(n%2==0) &#123; cnt0++; &#125; else cnt1++; n=n/2; &#125; cout&lt;&lt;cnt0&lt;&lt;" "&lt;&lt;cnt1; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1035 插入与归并]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[1035 插入与归并（25 分）根据维基百科的定义： 插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？输入格式：输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。输出格式：首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。输入样例 1： 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0输出样例 1： Insertion Sort 1 2 3 5 7 8 9 4 6 0输入样例 2： 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6输出样例 2： Merge Sort 1 2 3 8 4 5 7 9 0 6 思路：先将i指向中间序列中满足从左到右是从小到大顺序的最后一个下标，再将j指向从i+1开始，第一个不满足a[j] == b[j]的下标，如果j顺利到达了下标n，说明是插入排序，再下一次的序列是sort(a, a+i+2);否则说明是归并排序。归并排序就别考虑中间序列了，直接对原来的序列进行模拟归并时候的归并过程，i从0到n/k，每次一段段得sort(a + i k, a + (i + 1) k);最后别忘记还有最后剩余部分的sort(a + n / k * k, a + n);这样是一次归并的过程。直到有一次发现a的顺序和b的顺序相同，则再归并一次，然后退出循环～题解：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() &#123; int N; int a[101], b[101]; // 原始序列a 中间序列b int i, j; cin&gt;&gt;N; for( i=0; i&lt;N; i++ ) cin&gt;&gt;A1[i]; for( i=0; i&lt;N; i++ ) cin&gt;&gt;A2[i]; for( i=0; b[i]&lt;=b[i+1] &amp;&amp; i&lt;N-1; i++ ) ; // i作为有序序列最后一个元素下标退出循环 for( j=++i; a[j]==b[j] &amp;&amp; j&lt;N; j++ ) ; // a b从第一个无序的元素开始，逐一比对 if( j==N )&#123;// 前半部分有序而后半部分未改动可以确定是插入排序 cout&lt;&lt;"Insertion Sort"&lt;&lt;endl; sort( a, a+i+1 ); &#125; else&#123; cout&lt;&lt;"Merge Sort"&lt;&lt;endl; int k = 1; int flag=1; //用来标记是否归并到 “中间序列” while( flag ) &#123; flag = 0; for( i=0; i&lt;N; i++ ) if( a[i]!=b[i] ) flag = 1; k*=2; for( i=0; i&lt;N/k; i++ ) sort( a+i*k, a+(i+1)*k ); i=k*(N/k); // 对非偶数序列的“尾巴”进行排序 if(i&lt;N-1) sort( a+k*(N/k), a+N ); &#125; &#125; cout&lt;&lt;a[0]; for( i=1; i&lt;N; i++ ) cout&lt;&lt;" "&lt;&lt;a[i]; cout&lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1055 集体照]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1055-%E9%9B%86%E4%BD%93%E7%85%A7%2F</url>
    <content type="text"><![CDATA[1055 集体照 （25 分)拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：每排人数为 N/K（向下取整），多出来的人全部站在最后一排；后排所有人的个子都不比前排任何人矮；每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）；若多人身高相同，则按名字的字典序升序排列。这里保证无重名。现给定一组拍照人，请编写程序输出他们的队形。输入格式：每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤10^4​总人数）和 K（≤10^4，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。输出格式：输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。输入样例：10 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159输出样例：Bob Tom Joe NickAnn Mike EvaTim Amy John 分析：拍照的最后一行是输出的第一行，人数是m=n-n/k*(k-1),其他行数均为m=n/k，用结构体+vector将身高降序排列，注意身高相同名字按升序排列，用while循环排列每一行，将每一行的排列结果的姓名储存在ans数组中，最中间一个学生应该排在m/2的下标位置，即ans[m / 2] = stu[t].name；然后排左边一列，ans数组的下标 j 从m/2-1开始，一直往左j–，而对于stu的下标 i，是从t+1开始，每次隔一个人选取（即i = i+2，因为另一些人的名字是给右边的），每次把stu[i]的name赋值给ans[j–]；排右边的队伍同理，ans数组的下标 j 从m/2 + 1开始，一直往右j++，stu的下标 i，从t+2开始，每次隔一个人选取（i = i+2），每次把stu[i]的name赋值给ans[j++]，然后输出当前已经排好的ans数组～每一次排完一列row-1，直到row等于0时退出循环表示已经排列并输出所有的行～123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct node&#123; string name; int high;&#125;;int cmp(struct node a,struct node b )&#123; return a.high!=b.high?a.high&gt;b.high:a.name&lt;b.name;&#125;int main()&#123; int n,k,m; cin&gt;&gt;n&gt;&gt;k; vector&lt;node&gt;stu(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].high; sort(stu.begin(),stu.end(),cmp); int t=0,row=k; while(row) &#123; if(row==k) m=n-n/k*(k-1); else m=n/k; vector&lt;string&gt;ans(m); ans[m/2]=stu[t].name; //处理左边一列 int j=m/2-1; for(int i=t+1;i&lt;t+m;i=i+2) ans[j--]=stu[i].name; //处理右边一列 j=m/2+1; for(int i=t+2;i&lt;t+m;i=i+2) ans[j++]=stu[i].name; cout&lt;&lt;ans[0]; for(int i=1;i&lt;m;i++) cout&lt;&lt;" "&lt;&lt;ans[i]; cout&lt;&lt;endl; t=t+m;row--; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdowm语法说明]]></title>
    <url>%2F2019%2F03%2F18%2FMarkdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[写博客什么的超级好用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990*斜体*_斜体第二种方法_**加粗**__加粗的第二种方法_____粗斜体___两个enter是换行，或者用&lt;/br&gt;标签表示换行用一行的=或者-表示一级标题和二级标题。如：一级标题=======二级标题--------也可以在前面加上一到六个#表示标题的1级到6级。如：# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题无序列表：在前面加上 * 或者 + 或者 - 然后加个空格：* ABC* DEF* GHI+ JKL+ MNO+ PQR- STU- VWX- YZZ有序列表：数字+英文句点+空格。如下：1. 呵呵2. 哈哈3. 嘿嘿4. 哼哼&amp;lt; // 会显示为”&lt;“&amp;amp; // 会显示为”&amp;“：在 href 属性里面，必须将 &amp; 转变为 &amp;amp;\. // 为了防止产生"1."变为有序列表，则可以写成"1\." * _ // 如果 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。&gt;只在整个段落的第一行最前面加上大于号可以显示引用（此时出现引用形式，并且为斜体）。但是引言内如果要断行，那个空行也必须在前面加上大于号。就像下面写的酱紫：&gt;&gt;区块引言也可以有级别，在前面加上不同数量的大于号即可。比如说这就是一个二级引言。&gt;&gt;&gt;这是一个三级引言。格式会显示为字体更小了。C++代码块语法高亮:前后使用```,在前面的三点后写上C++。建立分割线的方法有：* * ******- - --------------------超级链接：[超级链接显示的文字](超级链接的网址，可以是绝对路径、相对路径)也支持HTML格式的超级链接&lt;a href="https://www.baidu.com/"&gt;百度&lt;/a&gt;如果要标记一小段行内程序代码，可以用反引号把它包起来（`），像这样：Use the `printf()` function.插入图片：![图片的替换文字](图片的地址或路径)![风景区图片](/Snip20160202_227.png)Email邮件：&lt;123456789@qq.com&gt;锚点：(能够链接到某个一级标题)[想要显示的名称](#锚点的名称) 参考：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STL lower_bound & upper_bound]]></title>
    <url>%2F2019%2F01%2F02%2FC-STL-lower-bound-upper-bound%2F</url>
    <content type="text"><![CDATA[background首先，lower_bound和upper_bound是C++ STL中提供的非常实用的函数。其操作对象可以是vector、set以及map。lower_bound返回值一般是&gt;= 给定val的最小指针（iterator）。upper_bound返回值则是 &gt; 给定val的最小指针（iterator）。 vector中的lower_bound &amp; upper_bound1234567891011121314151617181920// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vectorint main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); // ^ up= std::upper_bound (v.begin(), v.end(), 20); // ^ std::cout &lt;&lt; "lower_bound at position " &lt;&lt; (low- v.begin()) &lt;&lt; '\n'; std::cout &lt;&lt; "upper_bound at position " &lt;&lt; (up - v.begin()) &lt;&lt; '\n'; return 0;&#125; set中的 lower_bound 和 upper_bound1234567891011121314151617181920212223// set::lower_bound/upper_bound#include &lt;iostream&gt;#include &lt;set&gt;int main ()&#123; std::set&lt;int&gt; myset; std::set&lt;int&gt;::iterator itlow,itup; for (int i=1; i&lt;10; i++) myset.insert(i*10); // 10 20 30 40 50 60 70 80 90 itlow=myset.lower_bound (30); // ^ itup=myset.upper_bound (60); // ^ // 由于set中没有像vector中那样排序的概念，因此itlow - myset.begin()是错误的，itlow重载这类运算符 myset.erase(itlow,itup); // 10 20 70 80 90 // erase 删除时传入两个iterator，同样删除区间是左闭右开 std::cout &lt;&lt; "myset contains:"; for (std::set&lt;int&gt;::iterator it=myset.begin(); it!=myset.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; map中的lower_bound 和 upper_bound12345678910111213141516171819202122232425// map::lower_bound/upper_bound#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) 同样返回的是&gt;'d'对应的iterator mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《慢慢来，一切都来得及》读书笔记]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[因为我知道自己每一天都在认真地生活着，因为我正努力一步步朝着梦想迈进，因此每一天过得还算充实和快乐。这样一想我就不再焦虑了。我又问自己，如果给自己两年的时间去学习英语口语，慢慢来，给自己20年的时间去实现梦想，慢慢来，可以吗？答案是可以。我顿时整个人放松下来，当我允许自己慢慢来时，忽然感觉那种轻装上阵，脚踏实地的坚实力量又回到了自己的身上。有朋友问我，你会一直待在上海吗？我会回答不知道，因为我觉得未来是迷茫的，未来的事情也是难以预料的。我对生活一直怀有很多困惑，我觉得正是这些困惑推动着我不断去思考、去努力、去前进。 你问我不知道自己想要什么，怎么办？我会告诉你，那你赶紧去找啊。在20岁出头的年纪，不知道自己想要什么是一件极其正常的事情，也是一件幸运的事情，因为当你有了困惑之后，你才会思考，才会一步步地寻找自己想要的东西。 如果你真的没有发现自己喜欢的事情，那请不要放过任何尝试的机会，你可以接受各种挑战，尝试去做各种事情，不要拿自己太当回事了，丢弃那虚妄的自尊，不要怕出丑不要怕失败，你甚至要允许自己经常失败，给你面对失败的经验，给自己不断重新再来的勇气，你要做的就是积极地尝试，直到找到自己内心真正的热爱，找到自己愿意为之努力的梦想。要给自己时间，让自己慢慢来，给自己面对失败的勇气和对梦想持续的热情，因为最难的事情不是面对失败，而是面对一而再再而三的失败还能永保热情。 人生从来不是规划出来的，而是一步步走出来的。找到自己喜欢的事情，每天做那么一点点，时间一长，你就会看到自己的成长。 对于很多像我一样缺乏独立思考能力，又不懂得借鉴他人历史教训的人，只有亲身经历过，才能知道自己想要什么样的生活，就算不知道自己到底想要的是怎样的生活，也至少能明白自己不想要怎样的生活。 我一直想不明白，怎么有这么多人这样算计人生呢？人生真的不是算计出来的。有人说：“只有一次的生命，需要活得真性情一点。”真性情就是你不要压抑自己的需求，你要听从自己内心的声音，过自己想要的生活。也许我在念书的时候就结婚生孩子呢？就算念完书，年纪大了再结婚生子又怎样呢？就算我一辈子不结婚生孩子又怎样呢？难道就不会幸福吗？你的生活是需要别人对你说“好”你才会觉得好吗？你的安全感是来自符合社会习俗制定的标准吗？你的幸福感是建立在别人对你的生活投以羡慕嫉妒的目光上的吗？真正的强者是能在人生的旅途中蜕变为只对自己心声负责的达人。 那些早早找到自己的人生梦想，遵循天命的人，固然很幸运；但是，那些还没有找到自己应该走的道路的人也不必感到万分痛苦，因为一切都还来得及，你要给自己慢慢来的机会。我们乡下的老人常常告诫年轻人的一句话：饭要一口口地吃，路要一步步地走。 我常常告诫自己说，想做一件事就要立刻行动起来，不然就跟那些徒有羡慕之情却给自己诸多理由毫无行动的人们一个样。 只有一种英雄主义，就是在认清生活真相之后依然热爱生活 梭罗说：“生命并没有价值，除非你选择并赋予它价值。没有哪一个地方有幸福，除非你为自己带来幸福。” “常有人说我坚持得好，其实真正喜欢的事不用‘坚持’，让自己变得健康，真的很容易，不停地跑下去，就不会老。跑步可以沿途欣赏美景，享受运动的快乐，人生就是一场马拉松，谁健康，谁就能跑得更长远！” “做真正喜欢的事情不用坚持。” 所以，找到自己喜欢的事情非常重要。因为喜欢，你不用苦苦坚持，也因为喜欢，你愿意投入时间、精力，长久以往获得成功就是自然而然的事情。这一点同样适用在寻找爱人这件事上。找到自己真正喜欢的人，与之在一起，并不需要费力坚持，太过辛苦经营，只因为你们在一起是喜欢的、快乐的、充实的。在一起的时间越长，爱情如美酒一般变得愈加醇美。 就像山田本一所说的那样，拆分目标的好处在于：一、使得原本看起来有些吓人的大目标变得容易靠近和比较现实了。当你的心里认定这个目标可以实现时，就不会因为害怕失败而放弃你的行动。人做一件事拖延的原因有很多，其中一个就是把目标定得太高，害怕自己无法实现，其实就是恐惧失败。细化目标可以减少或者避免由于害怕失败而产生的拖延。二、细化目标还可以增加信心。当你觉得目标可以实现时、容易成功时，你就会更有信心。不言而喻的是信心对完成任务的作用很大。 吴淡如在《时间管理幸福学》中说道：“只要想到一件事情可以‘一石二鸟’或‘一石三鸟’我们比较容易有‘赚到’的感觉，会因为自己的‘贪恋’而继续下去。” “为一件事情找到多种目的”在工作和学习中都很适用。 做一件事情时，加强它的正面意义，为它多找一些其他目的，不仅能让你快乐地完成这件事，还让你的生活变得积极而高效，充满正能量。 下雨天的时候，一下班我就匆匆回家，刚到楼梯口，嘴里就念着：泡面、泡面、荷包蛋、荷包蛋……（我是个多容易满足的正牌吃货啊）然后“咔嚓”一声开门，蹬掉高跟鞋，用平底锅煮泡面吃，就着外面的雨声，吃着热气腾腾的荷包蛋泡面。下雨的夜晚，抱着锅，吃着泡面，我会感觉很幸福呢！ 孤独要趁好时光。趁着好时光，独自欣赏月升日落，独自面对生活的波澜起伏。孤独是人生的重要伴侣，学会独处，乐在独处的人也许过得才最自由自在。越来越觉得人的一生归根结底是与自己相处，与自己斗争的过程，要与自己的万千情绪相处，与自己的各种欲望斗争，与自己的软弱、惰性、劣势不停地斗争下去，爱恨情仇，贪嗔痴慢全是你自己一个人的。 上周和许久未见的一个朋友见面，他说我变得自信了。我明白我的自信不是来自薪水的增加、消费能力的提高或者工作能力的增强，而是来源于相信自己有进一步完善自己、改变自己的能力，同时能看到自己的局限，做得到改变能够改变的，接受不能改变的；相信自己有爱自己、爱他人的能力；相信自己一个人生活也过得好。 以前我一直在逃离生活，与生活保持着一定的距离，觉得走到哪里，怎样的生活都不是自己想要的。这两年我感觉自己渐渐脚踏实地了，开始贴着生活在好好地过日子，虽然做得还不够好，但是一直在进步。蓦然回首，我一个人走过了那么多时光，也走了很远，从乡村到都市，从荒凉到繁华，从深夜到清晨，从弱小到强大，从艰难到轻松，从痛苦到狂喜，所有的这些我都一个人一一走过，虽然我走得慢，但是我走得很认真很努力，从没有因为害怕而停止。 通过观察和经验，我发现那些稍微准备就去干的人和非要准备充分才去行动的人最大的区别就在于对人生的认知不同。前者认为人生是各种体验的集合，后者认为人生是各种成功的档案。因此前者往往充满活力和冒险精神，充满勇气和自信。注重过程，乐于接受变化和挑战，不惧怕失败，情绪乐观，面对失败也较轻松和正面，觉得至少能收获一份经验。这样的人常常大胆尝试，敢于打破规则，愿意去做许多未知的事情；后者则畏首畏尾，缺乏勇气和自信，全然以目标为导向。害怕变化和挑战，也非常害怕失败，只要一失败简直会要了他的命，压力沉重，甚至陷入无法自拔的沮丧和毁灭之中，这样的人因为很多的不敢为，所以经历的事情也比较少，囿于自身思维中的各种限制，躲在自己认为的安全区中。 李欣频说：“当你匮乏时不会有人把资源给你，只有当你真正丰富了才会给你。”当你真正做到踏踏实实地完善自己、丰富自己，专心做可以提升自己的事情，学习并拥有更高的技能的时候，很多机会就会降临到你身上。 你经受的每一份痛苦都是上天赐予你的一份神秘礼物（其实能这样想还真不容易），我希望你能从所受的每一份痛苦中获得学习、累积和成长。如果你经历的痛苦仅仅是痛苦，无法将痛苦转换成人生的养分，去灌注自己内心的坚强之花，那么你也许一辈子都痛苦脆弱，与坚强无缘，也找不到自己的存在感。 我一边心不甘情不愿地写着方案，一边想到后面还有那么多工作要做，想着明天就要提交工作成果了。重压、愤怒、怨恨、控诉、敌意和挫败等负面情绪一股脑地冲向我，我崩溃了，居然呜呜地哭了起来。意识到眼泪正夺眶而出，我被自己“正在哭”这一事实吓坏了，这虽然不是我第一次因为工作压力大而哭泣，但那是前两年的事情了，现在我毕竟是工作了三年的职场之人，怎么就这样脆弱，不堪一击？这时心中有一个声音响起：“哭能解决问题吗？难道有人逼你这样做吗？现在这个局面是谁造成的？你打算怎么办？” 趋利避害，逃避责任，这是每一个人都会有的正常心理，但是这并不代表它是好东西，相反，这正是导致许多人生活不幸的原因。 是的，我们需要停止抱怨，抱怨只会带来坏处，一点正面积极的好处都没有的，它会分散你的注意力，消耗你的精力，瓦解你的信心，摧毁你的行动力。抱怨还会限制我们思考，阻挡我们有效工作。因为，当我们抱怨的时候就把焦点放在我们不想要的东西上，所谈论的是负面的、出错的事情，而我们把注意力放在什么上头，那个东西就会扩大。我们抱怨的言语会影响我们的思维，进而影响我们的想法和态度，从而给我们的生活带来负面的影响。同时抱怨还会影响我们的人际关系。试想一下，谁愿意跟一个成天抱怨的人在一起共事呢？ Bronnie Ware专门照顾那些临终病人，听到很多人临终前说出他们一生里最后悔的事。她作了一个概括，有5件事是大多数人最后悔的。 我希望当初我有勇气过自己真正想要的生 活，而不是别人希望我过的生活。 我希望当初我没有花这么多精力在工作上。 我希望当初我能有勇气表达我的感受。 我希望当初我能和朋友保持联系。 我希望当初我能让自己活得开心点。 亲自听闻了1000多例病患的临终遗言后，他写下了这本书，其中排在前五位的是： 没做自己想做的事。 没有实现梦想。 做过对不起良心的事。 被感情左右度过一生。 没有尽力帮助过别人。 我想，人生的意义对任何人来说都显得重要。德国哲学家威廉·施密德在自己《幸福》一书中表达了这样的观点：幸福并不是人生的第一要义，意义才是。我们真正要寻找和建立的并不是幸福，而是意义。我想也许当我们找到自己人生的意义时，我们会觉得自己更有价值，更幸福，更能够战胜人生的虚无和幻灭。 我主张积极地看待自己的童年阴影。如果我们过去的经验、受到的教育、家庭环境和社会环境决定了我们的未来，那不是说明我们的人生早早就被安排好了，这听起来多可怕啊？把自己的问题全部归咎于童年阴影是很不负责的，置自己的主观能动性和创造性于何处？如果依照这种理论，你会带着很负面的能量生活，我劝大家不要信奉。 虽然全世界72.8%的人都会得拖延症，虽然拖延症是个可怕的顽疾，但是治疗起来却也很简单：立即行动。连岳在他的专栏里说：“有什么事让你拖得心烦，先做三分钟再说。如果你是个专栏作家，从昨晚开始就在拖一篇文章，那不如现在马上坐下，打开写字板，先写180秒，于是，奇迹发生了。三分钟后你会继续写，直到把文章写完。” 《少有人走的路》中说“推迟满足感，意味着不贪图暂时的安逸，重新设置人生快乐与痛苦的次序：首先，面对问题并感受痛苦；然后，解决问题并享受更大的快乐，这是唯一可行的生活方式” 不要草率地给自己贴标签。如果你并没有连续20几天持续睡不着、晚睡，只是因为诸如失恋、情绪低落、被领导批评、工作不顺等，那么，不要给自己贴上失眠症、晚睡强迫症、抑郁症之类的标签。这并不是一件值得赶时髦的事情，因为一旦贴上标签，你容易躲在这个舒适的标签里，不愿对自己负责，没有改变自己行为的动力和能量。 管理好白天的时间。不要认为很多事情白天干不了、干不好，这是不良的心理暗示。我有个朋友认为白天写不了文章，只有夜深人静的时候才能安心写稿，其实白天一样可以写稿子，只要自己开始动笔写起来，就会投入其中。学会积极地在白天做科学的时间规划，提高白天的工作效率，避免拖拉，将工作任务在白天完成，把晚上留给睡眠。 每年的3月21日是世界睡眠日，在这一天全球性健康睡眠主题公益活动中有一个“多睡一小时”的活动 让我们互道一声晚安 送走这匆匆的一天 值得怀念的请你珍藏 应该忘记的莫再留恋 让我们互道一声晚安 迎接那崭新的明天 把握那美好的前程 珍惜你锦绣的人生 愿你走进甜甜的梦乡 祝你有个宁静的夜晚 晚安 晚安 再说一声 明天见 你在哪一方面花了时间，那一方面就会回馈给你成果，一切的付出都不会白费如流水。学习如是，工作如是，恋爱亦如是。 兴趣真的有那么重要吗？其实不然。兴趣带来的热情只是最初的火种，想要形成燎原之势还需要我们持续不懈地投入，人是因为把一件事情干得越来越好才越来越有兴趣的，不是对什么感兴趣才干得好。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first blood]]></title>
    <url>%2F2018%2F12%2F11%2Ffirstblood%2F</url>
    <content type="text"><![CDATA[This is my first blog!不忘初心，假装这里有很多字嗯，写完了，滚去四级备考了 考试必过！]]></content>
      <tags>
        <tag>哎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
