<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读书笔记及一些杂谈]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[YOLO]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建个人博客]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%9D%A5%E8%87%AAwd%E5%AD%A6%E9%95%BF%E7%9A%84%E5%8F%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[友链看学长写的加各种百度就能建站了（很容易的，我也就熬了几个夜；]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1035 插入与归并]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[1035 插入与归并（25 分）根据维基百科的定义： 插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？输入格式：输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。输出格式：首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。输入样例 1： 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0输出样例 1： Insertion Sort 1 2 3 5 7 8 9 4 6 0输入样例 2： 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6输出样例 2： Merge Sort 1 2 3 8 4 5 7 9 0 6 思路：先将i指向中间序列中满足从左到右是从小到大顺序的最后一个下标，再将j指向从i+1开始，第一个不满足a[j] == b[j]的下标，如果j顺利到达了下标n，说明是插入排序，再下一次的序列是sort(a, a+i+2);否则说明是归并排序。归并排序就别考虑中间序列了，直接对原来的序列进行模拟归并时候的归并过程，i从0到n/k，每次一段段得sort(a + i k, a + (i + 1) k);最后别忘记还有最后剩余部分的sort(a + n / k * k, a + n);这样是一次归并的过程。直到有一次发现a的顺序和b的顺序相同，则再归并一次，然后退出循环～题解：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() &#123; int N; int a[101], b[101]; // 原始序列a 中间序列b int i, j; cin&gt;&gt;N; for( i=0; i&lt;N; i++ ) cin&gt;&gt;A1[i]; for( i=0; i&lt;N; i++ ) cin&gt;&gt;A2[i]; for( i=0; b[i]&lt;=b[i+1] &amp;&amp; i&lt;N-1; i++ ) ; // i作为有序序列最后一个元素下标退出循环 for( j=++i; a[j]==b[j] &amp;&amp; j&lt;N; j++ ) ; // a b从第一个无序的元素开始，逐一比对 if( j==N )&#123;// 前半部分有序而后半部分未改动可以确定是插入排序 cout&lt;&lt;"Insertion Sort"&lt;&lt;endl; sort( a, a+i+1 ); &#125; else&#123; cout&lt;&lt;"Merge Sort"&lt;&lt;endl; int k = 1; int flag=1; //用来标记是否归并到 “中间序列” while( flag ) &#123; flag = 0; for( i=0; i&lt;N; i++ ) if( a[i]!=b[i] ) flag = 1; k*=2; for( i=0; i&lt;N/k; i++ ) sort( a+i*k, a+(i+1)*k ); i=k*(N/k); // 对非偶数序列的“尾巴”进行排序 if(i&lt;N-1) sort( a+k*(N/k), a+N ); &#125; &#125; cout&lt;&lt;a[0]; for( i=1; i&lt;N; i++ ) cout&lt;&lt;" "&lt;&lt;a[i]; cout&lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1054 求平均值]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1054 求平均值 （20 分) 本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。输入格式：输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。输出格式：对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。输入样例 1：75 -3.2 aaa 9999 2.3.4 7.123 2.35输出样例 1：ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38输入样例 2：2aaa -9999输出样例 2：ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 分析：使用sscanf和sprintf函数～sscanf() – 从一个字符串中读进与指定格式相符的数据sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中 题解：12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int n,cnt=0; char a[50],b[50]; cin&gt;&gt;n; double temp,sum=0.0; for(int i=0;i&lt;n;i++) &#123; scanf("%s",a); sscanf(a,"%lf",&amp;temp);//从7.123中读入7.123道temp中 sprintf(b,"%.2f",temp);//把temp变为7.12写入b中 int flag=0; for(int j=0;j&lt;strlen(a);j++) if(a[j]!=b[j])flag=1; if(flag||temp&lt;-1000||temp&gt;1000) &#123; printf("ERROR: %s is not a legal number\n",a); continue; &#125; else &#123; sum+=temp; cnt++; &#125; &#125; if(cnt==1) printf("The average of 1 number is %.2f",sum); else if(cnt&gt;1) printf("The average of %d numbers is %.2f",cnt,sum/cnt); else printf("The average of 0 numbers is Undefined"); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1057 数壹零]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1057-%E6%95%B0%E5%A3%B9%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[1057 数零壹 （20 分) 给定一串长度不超过 10^5的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 PAT (Basic)，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。输入格式：输入在一行中给出长度不超过 10^5,以回车结束的字符串。输出格式：在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。输入样例：PAT (Basic)输出样例：3 4 分析：用getline接收一行字符串，对于字符串的每一位，如果是字母(isalpha)，则将字母转化为大写(toupper)，并累加(s[i] – ‘A’ + 1)算出n，然后将n转化为二进制，对每一位处理，如果是0则cnt0++，如果是1则cnt1++，最后输出cnt0和cnt1的值～～题解：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;using namespace std;int main()&#123; string s; getline(cin,s); int n=0; for(int i=0;i&lt;s.length();i++) &#123; if(isalpha(s[i])) &#123; s[i]=toupper(s[i]); n+=(s[i]-'A'+1); &#125; &#125; int cnt0=0,cnt1=0; while(n!=0) &#123; if(n%2==0) &#123; cnt0++; &#125; else cnt1++; n=n/2; &#125; cout&lt;&lt;cnt0&lt;&lt;" "&lt;&lt;cnt1; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1055 集体照]]></title>
    <url>%2F2019%2F03%2F18%2FPAT-1055-%E9%9B%86%E4%BD%93%E7%85%A7%2F</url>
    <content type="text"><![CDATA[1055 集体照 （25 分)拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：每排人数为 N/K（向下取整），多出来的人全部站在最后一排；后排所有人的个子都不比前排任何人矮；每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）；若多人身高相同，则按名字的字典序升序排列。这里保证无重名。现给定一组拍照人，请编写程序输出他们的队形。输入格式：每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤10^4​总人数）和 K（≤10^4，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。输出格式：输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。输入样例：10 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159输出样例：Bob Tom Joe NickAnn Mike EvaTim Amy John 分析：拍照的最后一行是输出的第一行，人数是m=n-n/k*(k-1),其他行数均为m=n/k，用结构体+vector将身高降序排列，注意身高相同名字按升序排列，用while循环排列每一行，将每一行的排列结果的姓名储存在ans数组中，最中间一个学生应该排在m/2的下标位置，即ans[m / 2] = stu[t].name；然后排左边一列，ans数组的下标 j 从m/2-1开始，一直往左j–，而对于stu的下标 i，是从t+1开始，每次隔一个人选取（即i = i+2，因为另一些人的名字是给右边的），每次把stu[i]的name赋值给ans[j–]；排右边的队伍同理，ans数组的下标 j 从m/2 + 1开始，一直往右j++，stu的下标 i，从t+2开始，每次隔一个人选取（i = i+2），每次把stu[i]的name赋值给ans[j++]，然后输出当前已经排好的ans数组～每一次排完一列row-1，直到row等于0时退出循环表示已经排列并输出所有的行～123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct node&#123; string name; int high;&#125;;int cmp(struct node a,struct node b )&#123; return a.high!=b.high?a.high&gt;b.high:a.name&lt;b.name;&#125;int main()&#123; int n,k,m; cin&gt;&gt;n&gt;&gt;k; vector&lt;node&gt;stu(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].high; sort(stu.begin(),stu.end(),cmp); int t=0,row=k; while(row) &#123; if(row==k) m=n-n/k*(k-1); else m=n/k; vector&lt;string&gt;ans(m); ans[m/2]=stu[t].name; //处理左边一列 int j=m/2-1; for(int i=t+1;i&lt;t+m;i=i+2) ans[j--]=stu[i].name; //处理右边一列 j=m/2+1; for(int i=t+2;i&lt;t+m;i=i+2) ans[j++]=stu[i].name; cout&lt;&lt;ans[0]; for(int i=1;i&lt;m;i++) cout&lt;&lt;" "&lt;&lt;ans[i]; cout&lt;&lt;endl; t=t+m;row--; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdowm语法说明]]></title>
    <url>%2F2019%2F03%2F18%2FMarkdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[写博客什么的超级好用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990*斜体*_斜体第二种方法_**加粗**__加粗的第二种方法_____粗斜体___两个enter是换行，或者用&lt;/br&gt;标签表示换行用一行的=或者-表示一级标题和二级标题。如：一级标题=======二级标题--------也可以在前面加上一到六个#表示标题的1级到6级。如：#一级标题##二级标题###三级标题####四级标题#####五级标题######六级标题无序列表：在前面加上 * 或者 + 或者 - 然后加个空格：* ABC* DEF* GHI+ JKL+ MNO+ PQR- STU- VWX- YZZ有序列表：数字+英文句点+空格。如下：1. 呵呵2. 哈哈3. 嘿嘿4. 哼哼&amp;lt; // 会显示为”&lt;“&amp;amp; // 会显示为”&amp;“：在 href 属性里面，必须将 &amp; 转变为 &amp;amp;\. // 为了防止产生"1."变为有序列表，则可以写成"1\." * _ // 如果 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。&gt;只在整个段落的第一行最前面加上大于号可以显示引用（此时出现引用形式，并且为斜体）。但是引言内如果要断行，那个空行也必须在前面加上大于号。就像下面写的酱紫：&gt;&gt;区块引言也可以有级别，在前面加上不同数量的大于号即可。比如说这就是一个二级引言。&gt;&gt;&gt;这是一个三级引言。格式会显示为字体更小了。C++代码块语法高亮:前后使用```,在前面的三点后写上C++。建立分割线的方法有：* * ******- - --------------------超级链接：[超级链接显示的文字](超级链接的网址，可以是绝对路径、相对路径)也支持HTML格式的超级链接&lt;a href="https://www.baidu.com/"&gt;百度&lt;/a&gt;如果要标记一小段行内程序代码，可以用反引号把它包起来（`），像这样：Use the `printf()` function.插入图片：![图片的替换文字](图片的地址或路径)![风景区图片](/Snip20160202_227.png)Email邮件：&lt;123456789@qq.com&gt;锚点：(能够链接到某个一级标题)[想要显示的名称](#锚点的名称)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STL lower_bound & upper_bound]]></title>
    <url>%2F2019%2F01%2F02%2FC-STL-lower-bound-upper-bound%2F</url>
    <content type="text"><![CDATA[background首先，lower_bound和upper_bound是C++ STL中提供的非常实用的函数。其操作对象可以是vector、set以及map。lower_bound返回值一般是&gt;= 给定val的最小指针（iterator）。upper_bound返回值则是 &gt; 给定val的最小指针（iterator）。 vector中的lower_bound &amp; upper_bound1234567891011121314151617181920// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vectorint main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); // ^ up= std::upper_bound (v.begin(), v.end(), 20); // ^ std::cout &lt;&lt; "lower_bound at position " &lt;&lt; (low- v.begin()) &lt;&lt; '\n'; std::cout &lt;&lt; "upper_bound at position " &lt;&lt; (up - v.begin()) &lt;&lt; '\n'; return 0;&#125; set中的 lower_bound 和 upper_bound1234567891011121314151617181920212223// set::lower_bound/upper_bound#include &lt;iostream&gt;#include &lt;set&gt;int main ()&#123; std::set&lt;int&gt; myset; std::set&lt;int&gt;::iterator itlow,itup; for (int i=1; i&lt;10; i++) myset.insert(i*10); // 10 20 30 40 50 60 70 80 90 itlow=myset.lower_bound (30); // ^ itup=myset.upper_bound (60); // ^ // 由于set中没有像vector中那样排序的概念，因此itlow - myset.begin()是错误的，itlow重载这类运算符 myset.erase(itlow,itup); // 10 20 70 80 90 // erase 删除时传入两个iterator，同样删除区间是左闭右开 std::cout &lt;&lt; "myset contains:"; for (std::set&lt;int&gt;::iterator it=myset.begin(); it!=myset.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; map中的lower_bound 和 upper_bound12345678910111213141516171819202122232425// map::lower_bound/upper_bound#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) 同样返回的是&gt;'d'对应的iterator mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《慢慢来，一切都来得及》读书笔记]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[因为我知道自己每一天都在认真地生活着，因为我正努力一步步朝着梦想迈进，因此每一天过得还算充实和快乐。这样一想我就不再焦虑了。我又问自己，如果给自己两年的时间去学习英语口语，慢慢来，给自己20年的时间去实现梦想，慢慢来，可以吗？答案是可以。我顿时整个人放松下来，当我允许自己慢慢来时，忽然感觉那种轻装上阵，脚踏实地的坚实力量又回到了自己的身上。有朋友问我，你会一直待在上海吗？我会回答不知道，因为我觉得未来是迷茫的，未来的事情也是难以预料的。我对生活一直怀有很多困惑，我觉得正是这些困惑推动着我不断去思考、去努力、去前进。 你问我不知道自己想要什么，怎么办？我会告诉你，那你赶紧去找啊。在20岁出头的年纪，不知道自己想要什么是一件极其正常的事情，也是一件幸运的事情，因为当你有了困惑之后，你才会思考，才会一步步地寻找自己想要的东西。 如果你真的没有发现自己喜欢的事情，那请不要放过任何尝试的机会，你可以接受各种挑战，尝试去做各种事情，不要拿自己太当回事了，丢弃那虚妄的自尊，不要怕出丑不要怕失败，你甚至要允许自己经常失败，给你面对失败的经验，给自己不断重新再来的勇气，你要做的就是积极地尝试，直到找到自己内心真正的热爱，找到自己愿意为之努力的梦想。要给自己时间，让自己慢慢来，给自己面对失败的勇气和对梦想持续的热情，因为最难的事情不是面对失败，而是面对一而再再而三的失败还能永保热情。人生从来不是规划出来的，而是一步步走出来的。找到自己喜欢的事情，每天做那么一点点，时间一长，你就会看到自己的成长。 对于很多像我一样缺乏独立思考能力，又不懂得借鉴他人历史教训的人，只有亲身经历过，才能知道自己想要什么样的生活，就算不知道自己到底想要的是怎样的生活，也至少能明白自己不想要怎样的生活。 我一直想不明白，怎么有这么多人这样算计人生呢？人生真的不是算计出来的。有人说：“只有一次的生命，需要活得真性情一点。”真性情就是你不要压抑自己的需求，你要听从自己内心的声音，过自己想要的生活。也许我在念书的时候就结婚生孩子呢？就算念完书，年纪大了再结婚生子又怎样呢？就算我一辈子不结婚生孩子又怎样呢？难道就不会幸福吗？你的生活是需要别人对你说“好”你才会觉得好吗？你的安全感是来自符合社会习俗制定的标准吗？你的幸福感是建立在别人对你的生活投以羡慕嫉妒的目光上的吗？真正的强者是能在人生的旅途中蜕变为只对自己心声负责的达人。 那些早早找到自己的人生梦想，遵循天命的人，固然很幸运；但是，那些还没有找到自己应该走的道路的人也不必感到万分痛苦，因为一切都还来得及，你要给自己慢慢来的机会。我们乡下的老人常常告诫年轻人的一句话：饭要一口口地吃，路要一步步地走。 我常常告诫自己说，想做一件事就要立刻行动起来，不然就跟那些徒有羡慕之情却给自己诸多理由毫无行动的人们一个样。 只有一种英雄主义，就是在认清生活真相之后依然热爱生活 梭罗说：“生命并没有价值，除非你选择并赋予它价值。没有哪一个地方有幸福，除非你为自己带来幸福。” “常有人说我坚持得好，其实真正喜欢的事不用‘坚持’，让自己变得健康，真的很容易，不停地跑下去，就不会老。跑步可以沿途欣赏美景，享受运动的快乐，人生就是一场马拉松，谁健康，谁就能跑得更长远！” “做真正喜欢的事情不用坚持。” 所以，找到自己喜欢的事情非常重要。因为喜欢，你不用苦苦坚持，也因为喜欢，你愿意投入时间、精力，长久以往获得成功就是自然而然的事情。这一点同样适用在寻找爱人这件事上。找到自己真正喜欢的人，与之在一起，并不需要费力坚持，太过辛苦经营，只因为你们在一起是喜欢的、快乐的、充实的。在一起的时间越长，爱情如美酒一般变得愈加醇美。 就像山田本一所说的那样，拆分目标的好处在于：一、使得原本看起来有些吓人的大目标变得容易靠近和比较现实了。当你的心里认定这个目标可以实现时，就不会因为害怕失败而放弃你的行动。人做一件事拖延的原因有很多，其中一个就是把目标定得太高，害怕自己无法实现，其实就是恐惧失败。细化目标可以减少或者避免由于害怕失败而产生的拖延。二、细化目标还可以增加信心。当你觉得目标可以实现时、容易成功时，你就会更有信心。不言而喻的是信心对完成任务的作用很大。 吴淡如在《时间管理幸福学》中说道：“只要想到一件事情可以‘一石二鸟’或‘一石三鸟’我们比较容易有‘赚到’的感觉，会因为自己的‘贪恋’而继续下去。” “为一件事情找到多种目的”在工作和学习中都很适用。 做一件事情时，加强它的正面意义，为它多找一些其他目的，不仅能让你快乐地完成这件事，还让你的生活变得积极而高效，充满正能量。 下雨天的时候，一下班我就匆匆回家，刚到楼梯口，嘴里就念着：泡面、泡面、荷包蛋、荷包蛋……（我是个多容易满足的正牌吃货啊）然后“咔嚓”一声开门，蹬掉高跟鞋，用平底锅煮泡面吃，就着外面的雨声，吃着热气腾腾的荷包蛋泡面。下雨的夜晚，抱着锅，吃着泡面，我会感觉很幸福呢！ 孤独要趁好时光。趁着好时光，独自欣赏月升日落，独自面对生活的波澜起伏。孤独是人生的重要伴侣，学会独处，乐在独处的人也许过得才最自由自在。越来越觉得人的一生归根结底是与自己相处，与自己斗争的过程，要与自己的万千情绪相处，与自己的各种欲望斗争，与自己的软弱、惰性、劣势不停地斗争下去，爱恨情仇，贪嗔痴慢全是你自己一个人的。 上周和许久未见的一个朋友见面，他说我变得自信了。我明白我的自信不是来自薪水的增加、消费能力的提高或者工作能力的增强，而是来源于相信自己有进一步完善自己、改变自己的能力，同时能看到自己的局限，做得到改变能够改变的，接受不能改变的；相信自己有爱自己、爱他人的能力；相信自己一个人生活也过得好。 以前我一直在逃离生活，与生活保持着一定的距离，觉得走到哪里，怎样的生活都不是自己想要的。这两年我感觉自己渐渐脚踏实地了，开始贴着生活在好好地过日子，虽然做得还不够好，但是一直在进步。蓦然回首，我一个人走过了那么多时光，也走了很远，从乡村到都市，从荒凉到繁华，从深夜到清晨，从弱小到强大，从艰难到轻松，从痛苦到狂喜，所有的这些我都一个人一一走过，虽然我走得慢，但是我走得很认真很努力，从没有因为害怕而停止。 通过观察和经验，我发现那些稍微准备就去干的人和非要准备充分才去行动的人最大的区别就在于对人生的认知不同。前者认为人生是各种体验的集合，后者认为人生是各种成功的档案。因此前者往往充满活力和冒险精神，充满勇气和自信。注重过程，乐于接受变化和挑战，不惧怕失败，情绪乐观，面对失败也较轻松和正面，觉得至少能收获一份经验。这样的人常常大胆尝试，敢于打破规则，愿意去做许多未知的事情；后者则畏首畏尾，缺乏勇气和自信，全然以目标为导向。害怕变化和挑战，也非常害怕失败，只要一失败简直会要了他的命，压力沉重，甚至陷入无法自拔的沮丧和毁灭之中，这样的人因为很多的不敢为，所以经历的事情也比较少，囿于自身思维中的各种限制，躲在自己认为的安全区中。 李欣频说：“当你匮乏时不会有人把资源给你，只有当你真正丰富了才会给你。”当你真正做到踏踏实实地完善自己、丰富自己，专心做可以提升自己的事情，学习并拥有更高的技能的时候，很多机会就会降临到你身上。 你经受的每一份痛苦都是上天赐予你的一份神秘礼物（其实能这样想还真不容易），我希望你能从所受的每一份痛苦中获得学习、累积和成长。如果你经历的痛苦仅仅是痛苦，无法将痛苦转换成人生的养分，去灌注自己内心的坚强之花，那么你也许一辈子都痛苦脆弱，与坚强无缘，也找不到自己的存在感。 我一边心不甘情不愿地写着方案，一边想到后面还有那么多工作要做，想着明天就要提交工作成果了。重压、愤怒、怨恨、控诉、敌意和挫败等负面情绪一股脑地冲向我，我崩溃了，居然呜呜地哭了起来。意识到眼泪正夺眶而出，我被自己“正在哭”这一事实吓坏了，这虽然不是我第一次因为工作压力大而哭泣，但那是前两年的事情了，现在我毕竟是工作了三年的职场之人，怎么就这样脆弱，不堪一击？这时心中有一个声音响起：“哭能解决问题吗？难道有人逼你这样做吗？现在这个局面是谁造成的？你打算怎么办？” 趋利避害，逃避责任，这是每一个人都会有的正常心理，但是这并不代表它是好东西，相反，这正是导致许多人生活不幸的原因。 是的，我们需要停止抱怨，抱怨只会带来坏处，一点正面积极的好处都没有的，它会分散你的注意力，消耗你的精力，瓦解你的信心，摧毁你的行动力。抱怨还会限制我们思考，阻挡我们有效工作。因为，当我们抱怨的时候就把焦点放在我们不想要的东西上，所谈论的是负面的、出错的事情，而我们把注意力放在什么上头，那个东西就会扩大。我们抱怨的言语会影响我们的思维，进而影响我们的想法和态度，从而给我们的生活带来负面的影响。同时抱怨还会影响我们的人际关系。试想一下，谁愿意跟一个成天抱怨的人在一起共事呢？ Bronnie Ware专门照顾那些临终病人，听到很多人临终前说出他们一生里最后悔的事。她作了一个概括，有5件事是大多数人最后悔的。 我希望当初我有勇气过自己真正想要的生 活，而不是别人希望我过的生活。 我希望当初我没有花这么多精力在工作上。 我希望当初我能有勇气表达我的感受。 我希望当初我能和朋友保持联系。 我希望当初我能让自己活得开心点。 亲自听闻了1000多例病患的临终遗言后，他写下了这本书，其中排在前五位的是： 没做自己想做的事。 没有实现梦想。 做过对不起良心的事。 被感情左右度过一生。 没有尽力帮助过别人。 我想，人生的意义对任何人来说都显得重要。德国哲学家威廉·施密德在自己《幸福》一书中表达了这样的观点：幸福并不是人生的第一要义，意义才是。我们真正要寻找和建立的并不是幸福，而是意义。我想也许当我们找到自己人生的意义时，我们会觉得自己更有价值，更幸福，更能够战胜人生的虚无和幻灭。 我主张积极地看待自己的童年阴影。如果我们过去的经验、受到的教育、家庭环境和社会环境决定了我们的未来，那不是说明我们的人生早早就被安排好了，这听起来多可怕啊？把自己的问题全部归咎于童年阴影是很不负责的，置自己的主观能动性和创造性于何处？如果依照这种理论，你会带着很负面的能量生活，我劝大家不要信奉。 虽然全世界72.8%的人都会得拖延症，虽然拖延症是个可怕的顽疾，但是治疗起来却也很简单：立即行动。连岳在他的专栏里说：“有什么事让你拖得心烦，先做三分钟再说。如果你是个专栏作家，从昨晚开始就在拖一篇文章，那不如现在马上坐下，打开写字板，先写180秒，于是，奇迹发生了。三分钟后你会继续写，直到把文章写完。” 《少有人走的路》中说“推迟满足感，意味着不贪图暂时的安逸，重新设置人生快乐与痛苦的次序：首先，面对问题并感受痛苦；然后，解决问题并享受更大的快乐，这是唯一可行的生活方式” 不要草率地给自己贴标签。如果你并没有连续20几天持续睡不着、晚睡，只是因为诸如失恋、情绪低落、被领导批评、工作不顺等，那么，不要给自己贴上失眠症、晚睡强迫症、抑郁症之类的标签。这并不是一件值得赶时髦的事情，因为一旦贴上标签，你容易躲在这个舒适的标签里，不愿对自己负责，没有改变自己行为的动力和能量。 管理好白天的时间。不要认为很多事情白天干不了、干不好，这是不良的心理暗示。我有个朋友认为白天写不了文章，只有夜深人静的时候才能安心写稿，其实白天一样可以写稿子，只要自己开始动笔写起来，就会投入其中。学会积极地在白天做科学的时间规划，提高白天的工作效率，避免拖拉，将工作任务在白天完成，把晚上留给睡眠。 每年的3月21日是世界睡眠日，在这一天全球性健康睡眠主题公益活动中有一个“多睡一小时”的活动 让我们互道一声晚安 送走这匆匆的一天 值得怀念的请你珍藏 应该忘记的莫再留恋 让我们互道一声晚安 迎接那崭新的明天 把握那美好的前程 珍惜你锦绣的人生 愿你走进甜甜的梦乡 祝你有个宁静的夜晚 晚安 晚安 再说一声 明天见 你在哪一方面花了时间，那一方面就会回馈给你成果，一切的付出都不会白费如流水。学习如是，工作如是，恋爱亦如是。 兴趣真的有那么重要吗？其实不然。兴趣带来的热情只是最初的火种，想要形成燎原之势还需要我们持续不懈地投入，人是因为把一件事情干得越来越好才越来越有兴趣的，不是对什么感兴趣才干得好。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first blood]]></title>
    <url>%2F2018%2F12%2F11%2Ffirstblood%2F</url>
    <content type="text"><![CDATA[This is my first blog!不忘初心，假装这里有很多字嗯，写完了，滚去四级备考了 ！avatar]]></content>
      <tags>
        <tag>哎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
